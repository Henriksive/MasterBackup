% !TEX root = ../Article.tex
\chapter{Conclusion}
\label{ch:conclusion}

\section{Research questions}
\begin{itemize}
  \item \textit{``What are the limitations of smart cards in the context of hardware?''}\\
  There hardware limitations of smart cards are very dependent on which smart card you are using. Generally smart cards are limited when it comes to computing power and this has a huge effect on how resource intensive operations you are able to perform on the smart card. Secure cryptography are very resource intensive and our test results show that encrypting large amounts of data is unfeasible, both for public-key cryptography (RSA) and symmetric-key cryptography (AES). We performed tests regarding transfer speed and they show that the throughput of input/output are limited and that we often run the risk of running out of memory with large amounts of data.
  \item \textit{``What are the limitations of smart cards applications?''}\\
  We opted for using Java Card as our programming language. Our version of Java Card does not support advanced datatypes. This combined with the fact that all data being sent to/from the smart card is byte values creates a rigid environment with hardcoded values. Java Card does not support standard garbage collection and thus applications needs to be extra careful when allocating memory.
  \item \textit{``What are the types of use cases we are able to solve and strengthen the security of using smart cards?''}\\
  Even though smart cards have some areas with limitations we are able to identify use cases where smart cards can be applicable. In use cases involving cryptography a smart card can store the keys securely as well as encrypt/decrypt small amounts of data. Due to the fact that smart cards are tamper proof, meaning that you are not able to extract data (keys), we are confident that smart cards can alleviate threats such as stolen mobile devices and insecure communication channels.\mbox{}\\\\  We believe that smart cards can add an extra layer of security for areas that are already solved. In this thesis we described and analyzed a solution where we used smart cards as a basis for policy enforcement. Our comprehension is that this type of solution in conjunction with traditional policy enforcement systems will take security to a new level.
\end{itemize}

\section{Experience}
%After working with smart cards for roughly one year, we have gained quite a few experiences that we believe are worth sharing.
During this thesis we have gained insight and experience when working with smart cards. We believe sharing these experiences will increase the efficiency for others working on the field in the future.

\paragraph{Getting started with smart card programming}\mbox{}\\
Getting started with smart card programming can be difficult. After a few years with object-oriented programming most programmers will start to get comfortable using ``quality of life'' classes such as \texttt{ArrayList} and \texttt{Enum}. That world gets turned up-side down when moving to Java Card. One is  thrown back to an older Java version and as a programmer you will need to rethink how you solve problems and structure solutions. Most notable is the fact that all incoming data is in the form of a \texttt{byte} array that must be mapped to the correct datatypes. Missing functionality such as standard Java garbage collection and standard data types (\texttt{int}, \texttt{double}, etc.), makes Java Card programming cumbersome and requires time to adapt to.

\paragraph{Debugging smart card applications}\mbox{}\\
Debugging smart card applications differs from standard debugging. Normally when debugging you are able to insert breakpoint, inspect variables and monitor resource usage. The nature of smart cards is to be a secure and closed environment and thus it is hard to monitor how an application behaves. The debugging method we have available is: deploy the application, send data to it and see what the response is. If the response does not match expected output, the best way to debug is creating manual breakpoints. This can be done by adding a line of code returning the current value of variables in order to figure out where the error might be. Sometimes the smart card encounter runtime exceptions and sends a 2 byte response that is mapped to an error message \cite{javacardErrors}.

This type of debugging environment is exhausting and requires a lot of resources. Often we spent time trying to pinpoint an error only to later found out that the error code we got had nothing to with the actual problem. This was especially notable with errors regarding memory usage. One of the best advices concerning smart card debugging is: ``Test often with a big array of test data.''.

\paragraph{Java Card documentation}\mbox{}\\
The documentation available is very technical. This is not by any means a bad thing, but it do require developers to understand smart cards fully before using the documentation. When comparing Android and Java Card documentation, it is very apparent that Google has put a lot of effort into having an educational approach to the concepts before diving into the technical aspects. In the Java Card documentation there are very few examples of usage, and we spent a lot of time trying to figure out how to properly use classes and methods.

The gap between software and hardware is very apparent in the Java Card documentation. We often encountered functionality that was supposed to work, but did not work on our smart cards. The result of this was that when we encountered bugs, we did not know if it was a programming mistake or simply not supported by our smart cards. The best example of this was when we tried to use the \texttt{Cipher} class with algorithms that proved to not work on our smart cards (section \ref{sec:symmetricTest}).

\paragraph{Deploying smart card applications}\mbox{}\\
Deploying smart card applications to a smart card is a time consuming task. This became very apparent when working with micro SD smart cards. Deploying a new version to micro SD required us to: remove mSD from mobile device, insert mSD into computer, run install script, wait on install script to finish, insert mSD into mobile device. Following this procedure once in a while is not a big inconvenience, but in context of debugging it become very tedious to spend 1,5 minutes switching around the mSD card and waiting for the install script.

\paragraph{Literature}\mbox{}\\
A lot of the existing literature on smart cards focuses on the two areas banking and identification. Even though we share some use cases and challenges with these areas we cannot directly apply their solutions to our research. There are two reasons for this. The first reason is that smart cards in banking and identification have a very narrow objective with what the smart card's responsibility is, whereas our smart cards have many different responsibilities (authenticate, authorize, encrypt, key management, etc.). The second reason is that in both banking and identification the smart cards can rely on a third party (server) to verify every interaction, e.g., when paying with debit card (smart card) a server verifies the money transaction. After the initial binding of smart card and mobile device our solution's goal is that the smart card is independent.

The lack of literature on how other companies have solved similar problems to the ones we encountered, may be that many consider secrecy of their ``setup'' is a good way of keeping their system secure. For instance the problem ``How to bind a smart card to a mobile device''. Either companies working with smart cards and mobile devices do not perform a binding or they do not wish to disclose how they do it. We suspect the latter, but this is pure speculation.

The consequence of this is that we have to approach the smart card field by looking at hard facts. ISO standards, RFC standards and documentation directly from the vendors are our main resources. Our experience shows that gathering information directly from the vendor yields a better result than looking at third-party literature as the vendor can provide updated information. See the bibliography for what we consider the best sources for information on the research topic.

\section{Future work}
\label{sec:future}
The research we have presented in this thesis is a good starting point for developing custom security applications on the Android platform in conjunction with smart cards. The test cases we have looked into point to that micro SD cards have better performance than NFC cards, but our micro SD cards did not support extended APDUs and thus we cannot confirm that micro SD are better than NFC cards. More work on micro SD cards must be performed in order to confirm these suspicions.

We encountered numerous bugs and limitations when working with smart cards which we did not initially predict, and as a result the Android library and the smart card application is not as polished and refined as we had hoped it would be. This includes adding more pre-implemented functionality, refactoring code to be more readable and optimize code to achieve better performance. Additionally we believe it would be beneficial to look at the possibility of not being dependent on the Gemalto framework (manufacturer specific) for micro SD card communication.

Our evaluations of the proposed solutions are based on protocol analysis and proof of concept. It would be of great interest to perform penetration tests on the outlined solutions to confirm that: \textit{a)} We are able to implement all parts of the solution. \textit{b)} We can show that the solution is methodically tested against known attacks in today's society.
